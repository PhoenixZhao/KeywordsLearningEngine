/* 
* Copyright (C) 1997, SKTC  Ltd., 
* All Rights Reserved 
* Class name: ConstructDictioanry.java 
* Description: Build a general Dictionary using the lexicon and the files 
*  generated in Step 1 and Step 2;
*  
* Modification History: 
**********************************************************
* Date		           Author		    Comments
* 04  August 2011	   ZhaoHuan			Created
**********************************************************
*/

package com.skt.oms.KLE;
import java.io.*;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Vector;

/** 
 * Step 3: 
 * The ConstructDictionary class is mainly an string matching process.
 * The "lexicon-gen.data" is man-made sentiment dictionary and we have four 
 * results generated by the OLE system. Then we use these five files to match 
 * the "content-result.xml" to construct a new dictionary "lexicon-DC-temp.xml".
 */
public class ConstructDictionary {
	final static String NULL = "null";
	
	/**
	 * This is the main method of ConstructDictionary process.It calls the 
	 * Match method to complete the process.
	 */
	public static void Do(String strConRes, String strAttrRes, 
			String strCompRes,String strFuncsRes, String strPheRes,
				String strLexGen, String strDCTemp){
		try
		{
			Match(strConRes, strAttrRes, strCompRes, strFuncsRes, strPheRes, 
					strLexGen, strDCTemp);
		}
		catch(Exception e)
		{
			e.printStackTrace();
		}		
	}
	
	/**
	 * This Contains method deals with the "content-result.xml" and the 4 files
	 * generated in Step 2. If one matched, return the one,or return "null".
	 */
	private static String Contains(Vector<String> vecTemp, String strLine) {
		for (int i = 0; i < vecTemp.size(); i++) 
		{
			if (strLine.indexOf(vecTemp.elementAt(i)) != -1)
				{
					return vecTemp.elementAt(i);
				}
		}
		return NULL;
	}

	/**
	 * This Contains method deals with the "content-result.xml" and the 
	 * "lexicon-gen.dat". In the same way,if one matched, return the whole line
	 *  or return "null".
	 */
	private static String Contains(Vector<String> vecLex, String strLine,
			Vector<Integer> vecPol) {
		for (int i = 0; i < vecLex.size(); i++)
		{
			if (strLine.indexOf(vecLex.elementAt(i)) != -1)
				{
					return vecLex.elementAt(i) + "	"
							+ vecPol.elementAt(i);
				}
		}
		return NULL;
	}
	
	/**
	 * The Match method. It calls several methods to implement the program.
	 */
	private static void Match(String strConRes, String strAttrRes, 
			String strCompRes, String strFuncsRes, String strPheRes, 
			String strLexGen, String strDCTemp){
		try
		{
			BufferedReader bufRCon = new BufferedReader(new InputStreamReader(
					new FileInputStream(strConRes), "UTF-8"));
			BufferedReader bufRAttr = new BufferedReader(new InputStreamReader(
					new FileInputStream(strAttrRes), "UTF-8"));
			BufferedReader bufRComp = new BufferedReader(new InputStreamReader(
					new FileInputStream(strCompRes), "UTF-8"));
			BufferedReader bufRFuncs = new BufferedReader(new InputStreamReader(
					new FileInputStream(strFuncsRes), "UTF-8"));
			BufferedReader bufRPhe = new BufferedReader(new InputStreamReader(
					new FileInputStream(strPheRes), "UTF-8"));
			BufferedReader bufRLex = new BufferedReader(new InputStreamReader(
					new FileInputStream(strLexGen), "UTF-8"));
			BufferedWriter bufWDCT = new BufferedWriter(new OutputStreamWriter(
					new FileOutputStream(strDCTemp), "UTF-8"));
			
			String strCon = bufRCon.readLine();
			String strAttr = bufRAttr.readLine();
			Vector<String> vecAttr = new Vector<String>();
			
			String strComp = bufRComp.readLine();
			Vector<String> vecComp = new Vector<String>();
			
			String strFuncs = bufRFuncs.readLine();
			Vector<String> vecFuncs = new Vector<String>();
			
			String strPhe = bufRPhe.readLine();
			Vector<String> vecPhe = new Vector<String>();
			
			String strLex = bufRLex.readLine();
			Vector<String> vecLex = new Vector<String>();
			Vector<Integer> vecPol = new Vector<Integer>();
			
			HashMap<String, Integer> hmFreq = new HashMap<String , Integer>();
		
			strInput(strAttr, bufRAttr, vecAttr);
			strInput(strComp, bufRComp, vecComp);
			strInput(strFuncs, bufRFuncs, vecFuncs);
			strInput(strPhe, bufRPhe, vecPhe);
						
			while (strLex != null)
			{
				vecLex.add(strLex.substring(0, strLex.indexOf("\t")));
				vecPol.add(Integer.parseInt(strLex.substring(strLex.indexOf(
						"\t") + 1)));
				strLex = bufRLex.readLine();				
			}
			bufRLex.close();
			
			while (strCon != null)
			{
				if (strCon.equals(""))
				{
					strCon = bufRCon.readLine();
					continue;
				}
				
				strLex = Contains(vecLex, strCon, vecPol);
				if (strLex.equals("null"))
				{
					strCon = bufRCon.readLine();
					continue;			
				}
				else
				{
					String strNewLex = strLex.substring(0, strLex
							.indexOf("\t"));
					strComp = Contains(vecComp, strCon);
					strFuncs = Contains(vecFuncs, strCon);
					strPhe = Contains(vecPhe, strCon);
					strAttr = Contains(vecAttr, strCon);
					
					String strPol = strLex.substring(strLex.indexOf("\t") + 1);
					
					String strKey = strNewLex + "\t" + strComp + "\t" 
								+ strFuncs + "\t" + strPhe + "\t" + strAttr
								+ "\t" + strPol;
					if (hmFreq.containsKey(strKey))
					{
						//Using the hashMap to record the frequency.
						Integer intOldFreq = hmFreq.get(strKey);
						intOldFreq++;
						hmFreq.remove(strKey);
						hmFreq.put(strKey, intOldFreq);						
					}
					else 
					{
						hmFreq.put(strKey, 1);
					}					
				}
				strCon = bufRCon.readLine();
			}		

			Iterator itFreq = hmFreq.keySet().iterator();
			while (itFreq.hasNext())
			{
				//Write the processed data into the file in specific format.
				Object objKey = itFreq.next();
				bufWDCT.write(objKey + "\t" + hmFreq.get(objKey) + "\n");
			}
			bufRCon.close();
			bufWDCT.close();			
		}
		catch (Exception e)
		{
			e.printStackTrace();
		}	
	}
	
	/**
	 * The strInput method is to read the content from the 4 files and add 
	 * them into the specific vector for after use.
	 */
	public static void strInput(String strTemp, BufferedReader bufRTemp,
								Vector<String> vecTemp)
	{
		try
		{
			while (strTemp != null)
			{
				if (strTemp.equals(""))
				{
					strTemp = bufRTemp.readLine();
					continue;
				}
				else
				{
					vecTemp.add(strTemp);
					strTemp = bufRTemp.readLine();
				}					
			}
			bufRTemp.close();
		}
		catch (Exception e)
		{
			e.printStackTrace();
		}
	}
}